# current parsing:

CONST = (INTEGER | FLOAT | BIT_INIT | STRING)
GEN = TYPE (ARG_LIST)? (INDEX_LIST)? ID (ASSIGN EXPR)?
PORT = TYPE (ARG_LIST)? (INDEX_LIST)? INTERFACE_TYPE ID
SIG = (CONST)? TYPE (ARG_LIST)? (INDEX_LIST)? ID (ASSIGN EXPR)?
TYPE = ID
INDEX_LIST = INDEX*
INDEX = LBRACK EXPR (COLON EXPR)? RBRACK
ARG_LIST = LPAREN EXPR (COMMA EXPR)* RPAREN

EXPR = TERM (ADD_SUB TERM)*
TERM = FACT (MULT_DIV FACT)*
FACT = ((ADD_SUB | CAT) FACT) | CONST | (LPAREN EXPR RPAREN) | VAR
VAR = ID (INDEX_LIST)? (DOT ID (INDEX_LIST)?)?


# new parsing:

FILE = (IMPORT_LIB|LIB_DECL|MODULE_DECL)

IMPORT_LIB = IMPORT ID (DOT ID)?

LIB_DECL = LIBRARY ID COLON
LIB_VAR  = GEN
LIB_BLOCK = (FUNC_DECL|STRUCT_DECL|INTERFACE_DECL|VAR_DECL|ENUM_DECL)

STRUCT_DECL = STRUCT ID (FUNC_ARG_LIST)? COLON
STRUCT_FIELD = TYPE (CALL_ARG_LIST)? (INDEX_LIST)? ID

INTERFACE_DECL = INTERFACE ID (FUNC_ARG_LIST)? COLON
INTERFACE_FIELD = TYPE (CALL_ARG_LIST)? (INDEX_LIST)? BASE_INTERFACE ID

FUNC_DECL = DEF (ID|*_OPER) FUNC_ARG_LIST COLON
FUNC_END = RETURN (VAR|(LPAREN VAR (COMMA VAR)* RPAREN))

DECL_ARG_LIST = LPAREN DECL_ARG (COMMA DECL_ARG)* RPAREN
DECL_ARG = TYPE (STAR)* ID

CALL_ARG_LIST = LPAREN SIMP_EXPR (COMMA SIMP_EXPR)* RPAREN

CONST = (INTEGER | FLOAT | BIT_INIT | STRING)
GEN = TYPE (CALL_ARG_LIST)? (INDEX_LIST)? ID (ASSIGN CMPX_EXPR)?
PORT = TYPE (CALL_ARG_LIST)? (INDEX_LIST)? (BASE_INTERFACE|EXT_INTERFACE) ID
SIG = (CONSTANT)? TYPE (CALL_ARG_LIST)? (INDEX_LIST)? ID (ASSIGN CMPX_EXPR)?
TYPE = ID
INDEX_LIST = (LBRACK SLICE RBRACK)*
SLICE = SIMP_EXPR (COLON SIMP_EXPR)?

FORBLOCK = FOR ID IN (RANGE_EXPR|VAR) COLON
RANGE_EXPR = RANGE LPAREN SIMP_EXPR COMMA SIMP_EXPR (COMMA SIMP_EXPR)? RPAREN

CASEBLOCK = CASE LPAREN SIMP_EXPR RPAREN COLON
CASE_CHOICE = CHOICE COLON
CHOICE = (SLICE|ID|OTHERS)

IFBLOCK   = IF LPAREN SIMP_EXPR RPAREN COLON
ELIFBLOCK = ELIF LPAREN SIMP_EXPR RPAREN COLON
ELSEBLOCK = ELSE COLON

MODULE_INST = ID ID (LPAREN ID RPAREN)? COLON

ASSIGNMENT = VAR (ASSIGN|CMPD_ARITH_ASSIGN|CMPD_LOGICAL_ASSIGN) CMPX_EXPR

PROBLOCK = (PRO|APRO|SPRO)

ARCH_STATEMENTS = (ASSIGNMENT|FOR|CASE|IF|MODULE_INST|PROBLOCK)
FUNC_STATEMENTS = (ASSIGNMENT|FOR|CASE|IF|RETURN)
PRO_STATEMENTS  = (ASSIGNMENT|FOR|CASE|IF)

CMPX_EXPR = AGGREGATE | SIMP_EXPR
AGGREGATE = LBRACK ELEM_ASSOC (COMMA ELEM_ASSOC)* RBRACK
ELEM_ASSOC = CHOICE ASSIGN (AGGREGATE | SIMP_EXPR)

SIMP_EXPR = RELATION (LOGICAL_OPER RELATION)*
RELATION = SHIFT (RELATION_OPER SHIFT)*
SHIFT = TERM (SHIFT_OPER TERM)*
TERM = FACT ((ADD_SUB | CAT) FACT)*
FACT = EXPONENT ((STAR | DIV | MOD_REM) EXPONENT)*
EXPONENT = UNARY (EXP UNARY)*
UNARY = (ADD_SUB | NOT)? PRIMARY
PRIMARY = CONST | REPLICATE | (LPAREN SIMP_EXPR RPAREN) | FUNC | VAR
FUNC = ID CALL_ARG_LIST
REPLICATE = LCURBRAC SIMP_EXPR RCURBRAC
VAR = ID (INDEX_LIST)? (DOT ID (INDEX_LIST)?)?

# TODO:
- Add comments to final RTL
- Update expressions
- Library parsing
- Actually check scope
